package com.example.modules.{{module}}.service;

import com.example.core.service.BaseService;
import com.example.modules.{{module}}.model.{{entityName}};
import com.example.modules.{{module}}.repository.{{entityName}}Repository;
{{~#each relationships}}
{{~#if (eq relationType "ManyToOne")}}
import com.example.modules.{{../module}}.model.{{type}};
import com.example.modules.{{../module}}.repository.{{type}}Repository;
{{~else if (eq relationType "OneToMany")}}
import com.example.modules.{{../module}}.model.{{type}};
{{~/if}}
{{~/each}}

import org.springframework.stereotype.Service;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.List;

@Service
public class {{entityName}}Service extends BaseService<{{entityName}}> {

    protected final {{entityName}}Repository {{entityNameLowercase}}Repository;
{{~#each relationships}}
{{~#if (eq relationType "ManyToOne")}}
    private final {{type}}Repository {{name}}Repository;
{{~/if}}
{{~/each}}

    public {{entityName}}Service({{entityName}}Repository repository{{~#each relationships}}{{~#if (eq relationType "ManyToOne")}}, {{type}}Repository {{name}}Repository{{~/if}}{{~/each}}) {
    super(repository);
    this.{{entityNameLowercase}}Repository = repository;
{{~#each relationships}}
    {{~#if (eq relationType "ManyToOne")}}
    this.{{name}}Repository = {{name}}Repository;
    {{~/if}}
{{~/each}}
}

    @Override
    public {{entityName}} save({{entityName}} {{entityNameLowercase}}) {
{{~#each relationships}}
    {{~#if (eq relationType "ManyToOne")}}
        if ({{../entityNameLowercase}}.get{{capitalize name}}() != null && {{../entityNameLowercase}}.get{{capitalize name}}().getId() != null) {
        {{type}} {{name}} = {{name}}Repository.findById({{../entityNameLowercase}}.get{{capitalize name}}().getId())
            .orElseThrow(() -> new RuntimeException("{{type}} not found"));
        {{../entityNameLowercase}}.set{{capitalize name}}({{name}});
    }
    {{~/if}}
{{~/each}}


{{~#each relationships}}
    {{~#if (eq relationType "OneToMany")}}
        if ({{../entityNameLowercase}}.get{{capitalize name}}() != null) {
            for ({{type}} item : {{../entityNameLowercase}}.get{{capitalize name}}()) {
                item.set{{capitalize mappedBy}}({{../entityNameLowercase}});
            }
    }
    {{~/if}}
{{~/each}}
    return {{entityNameLowercase}}Repository.save({{entityNameLowercase}});
    }

    public {{entityName}} update(Long id, {{entityName}} {{entityNameLowercase}}Request) {
    {{entityName}} existing = {{entityNameLowercase}}Repository.findById(id)
        .orElseThrow(() -> new RuntimeException("{{entityName}} not found"));

// Copier les champs simples
{{~#each fields}}
    existing.set{{capitalize name}}({{entityNameLowercase}}Request.get{{capitalize name}}());
{{~/each}}

// Relations ManyToOne : mise à jour conditionnelle
{{~#each relationships}}
{{~#if (eq relationType "ManyToOne")}}
    if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null &&{{entityNameLowercase}}Request.get{{capitalize name}}().getId() != null) {
    {{type}} {{name}} = {{name}}Repository.findById({{entityNameLowercase}}Request.get{{capitalize name}}().getId())
        .orElseThrow(() -> new RuntimeException("{{type}} not found"));
    existing.set{{capitalize name}}({{name}});
    }
    // Sinon on garde la relation existante
{{~/if}}
{{~/each}}

// Relations OneToMany : synchronisation sécurisée
{{~#each relationships}}
{{~#if (eq relationType "OneToMany")}}
    existing.get{{capitalize name}}().clear();
    if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null) {
        for (var item : {{entityNameLowercase}}Request.get{{capitalize name}}()) {
        item.set{{capitalize mappedBy}}(existing); // remettre lien inverse
        existing.get{{capitalize name}}().add(item);
        }
    }
{{~/if}}
{{~/each}}

    return {{entityNameLowercase}}Repository.save(existing);
    }
}
