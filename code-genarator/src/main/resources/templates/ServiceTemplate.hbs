package com.example.modules.{{module}}.service;

import com.example.core.service.BaseService;
import com.example.modules.{{module}}.model.{{entityName}};
import com.example.modules.{{module}}.repository.{{entityName}}Repository;
{{~#each relationships}}
import com.example.modules.{{../module}}.model.{{type}};
import com.example.modules.{{../module}}.repository.{{type}}Repository;
{{~/each}}

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.List;
import java.util.ArrayList;

@Service
public class {{entityName}}Service extends BaseService<{{entityName}}> {

    protected final {{entityName}}Repository {{entityNameLowercase}}Repository;
{{~#each relationships}}
    private final {{type}}Repository {{name}}Repository;
{{~/each}}

    public {{entityName}}Service({{entityName}}Repository repository {{~#each relationships}}, {{type}}Repository {{name}}Repository{{/each}})
    {
        super(repository);
        this.{{entityNameLowercase}}Repository = repository;
        {{~#each relationships}}
        this.{{name}}Repository = {{name}}Repository;
        {{~/each}}
    }

    @Override
    public {{entityName}} save({{entityName}} {{entityNameLowercase}}) {
    // ---------- OneToMany ----------
        {{~#each relationships}}
        {{~#if (eq relationType "OneToMany")}}
        {{~#with (lookupInverseRelationship type mappedBy)}}
        if ({{../entityNameLowercase}}.get{{capitalize ../name}}() != null) {
            List<{{../type}}> managed{{capitalize ../name}} = new ArrayList<>();
            for ({{../type}} item : {{../entityNameLowercase}}.get{{capitalize ../name}}()) {
                if (item.getId() != null) {
                    {{../type}} existingItem = {{../name}}Repository.findById(item.getId())
                        .orElseThrow(() -> new RuntimeException("{{../type}} not found"));

                     existingItem.set{{capitalize name}}({{../entityNameLowercase}});
                     managed{{capitalize ../name}}.add(existingItem);
                } else {
                    item.set{{capitalize name}}({{../entityNameLowercase}});
                    managed{{capitalize ../name}}.add(item);
                }
            }
            {{../entityNameLowercase}}.set{{capitalize ../name}}(managed{{capitalize ../name}});
        }
    {{~/with}}
    {{/if}}
    {{~/each}}
    // ---------- ManyToMany ----------
        {{~#each relationships}}
        {{~#if (eq relationType "ManyToMany")}}
        if ({{../entityNameLowercase}}.get{{capitalize name}}() != null &&
            !{{../entityNameLowercase}}.get{{capitalize name}}().isEmpty()) {

            List<{{type}}> attached{{capitalize name}} = new ArrayList<>();
            for ({{type}} item : {{../entityNameLowercase}}.get{{capitalize name}}()) {
                if (item.getId() != null) {
                    {{type}} existingItem = {{name}}Repository.findById(item.getId())
                        .orElseThrow(() -> new RuntimeException("{{type}} not found with id " + item.getId()));
                    attached{{capitalize name}}.add(existingItem);
                } else {

                    {{type}} newItem = {{name}}Repository.save(item);
                    attached{{capitalize name}}.add(newItem);
                }
            }

            {{../entityNameLowercase}}.set{{capitalize name}}(attached{{capitalize name}});

            // côté propriétaire ({{type}} → {{../entityName}})
            attached{{capitalize name}}.forEach(it -> it.get{{capitalize inverseField}}().add({{../entityNameLowercase}}));
        }
        {{/if}}
        {{~/each}}
    // ---------- ManyToOne ----------
        {{~#each relationships}}
        {{~#if (eq relationType "ManyToOne")}}
        if ({{../entityNameLowercase}}.get{{capitalize name}}() != null) {
            if ({{../entityNameLowercase}}.get{{capitalize name}}().getId() != null) {
                {{type}} existing{{capitalize name}} = {{name}}Repository.findById(
                    {{../entityNameLowercase}}.get{{capitalize name}}().getId()
                ).orElseThrow(() -> new RuntimeException("{{type}} not found with id "
                    + {{../entityNameLowercase}}.get{{capitalize name}}().getId()));
                {{../entityNameLowercase}}.set{{capitalize name}}(existing{{capitalize name}});
            } else {
                // Nouvel objet ManyToOne → on le sauvegarde
                {{type}} new{{capitalize name}} = {{name}}Repository.save({{../entityNameLowercase}}.get{{capitalize name}}());
                {{../entityNameLowercase}}.set{{capitalize name}}(new{{capitalize name}});
            }
        }
        {{/if}}
        {{~/each}}
    // ---------- OneToOne ----------
        {{~#each relationships}}
        {{~#if (eq relationType "OneToOne")}}
        if ({{../entityNameLowercase}}.get{{capitalize name}}() != null) {
            if ({{../entityNameLowercase}}.get{{capitalize name}}().getId() != null) {
                {{type}} existing{{capitalize name}} = {{name}}Repository.findById({{../entityNameLowercase}}.get{{capitalize name}}().getId())
                    .orElseThrow(() -> new RuntimeException("{{type}} not found with id "
                        + {{../entityNameLowercase}}.get{{capitalize name}}().getId()));
                {{../entityNameLowercase}}.set{{capitalize name}}(existing{{capitalize name}});
            } else {
                // Nouvel objet → sauvegarde d'abord
                {{type}} new{{capitalize name}} = {{name}}Repository.save({{../entityNameLowercase}}.get{{capitalize name}}());
                {{../entityNameLowercase}}.set{{capitalize name}}(new{{capitalize name}});
            }

            {{../entityNameLowercase}}.get{{capitalize name}}().set{{capitalize inverseField}}({{../entityNameLowercase}});
        }
        {{/if}}
        {{~/each}}
    return {{entityNameLowercase}}Repository.save({{entityNameLowercase}});
}


    public {{entityName}} update(Long id, {{entityName}} {{entityNameLowercase}}Request) {
        {{entityName}} existing = {{entityNameLowercase}}Repository.findById(id)
            .orElseThrow(() -> new RuntimeException("{{entityName}} not found"));

    // Copier les champs simples
    {{~#each fields}}
        existing.set{{capitalize name}}({{entityNameLowercase}}Request.get{{capitalize name}}());
    {{~/each}}

    // ---------- Relations ManyToOne ----------
        {{~#each relationships}}
        {{~#if (eq relationType "ManyToOne")}}
        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null &&
            {{entityNameLowercase}}Request.get{{capitalize name}}().getId() != null) {

            {{type}} existing{{capitalize name}} = {{name}}Repository.findById(
                {{entityNameLowercase}}Request.get{{capitalize name}}().getId()
            ).orElseThrow(() -> new RuntimeException("{{type}} not found"));

            existing.set{{capitalize name}}(existing{{capitalize name}});
        } else {
            existing.set{{capitalize name}}(null);
        }
        {{/if}}
        {{~/each}}
    // ---------- Relations ManyToOne ----------
        {{~#each relationships}}
        {{~#if (eq relationType "ManyToMany")}}
        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null) {
            existing.get{{capitalize name}}().clear();

            List<{{type}}> {{name}}List = {{entityNameLowercase}}Request.get{{capitalize name}}().stream()
                .map(item -> {{name}}Repository.findById(item.getId())
                    .orElseThrow(() -> new RuntimeException("{{type}} not found")))
                .collect(Collectors.toList());

            existing.get{{capitalize name}}().addAll({{name}}List);

            // Mettre à jour le côté inverse
            {{name}}List.forEach(it -> {
                if (!it.get{{capitalize inverseField}}().contains(existing)) {
                    it.get{{capitalize inverseField}}().add(existing);
                }
            });
        }
        {{/if}}
        {{~/each}}
    // ---------- Relations OneToMany ----------
        {{~#each relationships}}
        {{~#if (eq relationType "OneToMany")}}
        existing.get{{capitalize name}}().clear();

        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null) {
            for (var item : {{entityNameLowercase}}Request.get{{capitalize name}}()) {
                {{type}} existingItem;
                if (item.getId() != null) {
                    existingItem = {{name}}Repository.findById(item.getId())
                        .orElseThrow(() -> new RuntimeException("{{type}} not found"));
                } else {
                existingItem = item;
                }

                existingItem.set{{capitalize mappedBy}}(existing);
                existing.get{{capitalize name}}().add(existingItem);
            }
        }
        {{/if}}
        {{~/each}}
    // ---------- Relations OneToOne ----------
    {{~#each relationships}}
    {{~#if (eq relationType "OneToOne")}}
        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null &&{{entityNameLowercase}}Request.get{{capitalize name}}().getId() != null) {

        {{type}} {{name}} = {{name}}Repository.findById({{entityNameLowercase}}Request.get{{capitalize name}}().getId())
                .orElseThrow(() -> new RuntimeException("{{type}} not found"));

        existing.set{{capitalize name}}({{name}});
        {{~#if mappedBy}}
        {{name}}.set{{capitalize mappedBy}}(existing);
        {{else if inverseField}}
        {{name}}.set{{capitalize inverseField}}(existing);
        {{~/if}}
        }
    {{/if}}
    {{~/each}}
    return {{entityNameLowercase}}Repository.save(existing);
}
    @Transactional
    public boolean deleteById(Long id) {
        Optional<{{entityName}}> entityOpt = repository.findById(id);
        if (entityOpt.isEmpty()) return false;

        {{entityName}} entity = entityOpt.get();
    // --- Dissocier OneToMany ---
        {{~#each relationships}}
        {{~#if (eq relationType "OneToMany")}}
        if (entity.get{{capitalize name}}() != null) {
            for (var child : entity.get{{capitalize name}}()) {
                {{~#if mappedBy}}
                // retirer la référence inverse
                child.set{{capitalize mappedBy}}(null);
                {{~/if}}
            }
            entity.get{{capitalize name}}().clear();
        }
        {{/if}}
        {{~/each}}
    // --- Dissocier ManyToMany ---
        {{~#each relationships}}
        {{~#if (eq relationType "ManyToMany")}}
        if (entity.get{{capitalize name}}() != null) {
            for ({{type}} item : new ArrayList<>(entity.get{{capitalize name}}())) {
                {{#if inverseField}}
                item.get{{capitalize inverseField}}().remove(entity); // retire côté inverse
                {{~/if}}
            }
            entity.get{{capitalize name}}().clear(); // puis vide côté courant
        }
        {{/if}}
        {{~/each}}
    // --- Dissocier OneToOne ---
        {{~#each relationships}}
        {{~#if (eq relationType "OneToOne")}}
        if (entity.get{{capitalize name}}() != null) {
            entity.get{{capitalize name}}().set{{capitalize inverseField}}(null);
            entity.set{{capitalize name}}(null);
        }
        {{/if}}
        {{~/each}}
    // --- Dissocier ManyToOne ---
        {{~#each relationships}}
        {{~#if (eq relationType "ManyToOne")}}
        if (entity.get{{capitalize name}}() != null) {
            entity.set{{capitalize name}}(null);
        }
        {{/if}}
        {{~/each}}
        repository.delete(entity);
        return true;
    }
    @Transactional
    public List<{{entityName}}> saveAll(List<{{entityName}}> {{entityNameLowercase}}List) {

        return {{entityNameLowercase}}Repository.saveAll({{entityNameLowercase}}List);
    }

}