package com.example.modules.{{module}}.service;

import com.example.core.service.BaseService;
import com.example.modules.{{module}}.model.{{entityName}};
import com.example.modules.{{module}}.repository.{{entityName}}Repository;
{{~#each relationships}}
{{~#if (eq relationType "ManyToOne")}}
import com.example.modules.{{../module}}.model.{{type}};
import com.example.modules.{{../module}}.repository.{{type}}Repository;
{{~else if (eq relationType "OneToMany")}}
import com.example.modules.{{../module}}.model.{{type}};
import com.example.modules.{{../module}}.repository.{{type}}Repository;
{{~else if (eq relationType "ManyToMany")}}
import com.example.modules.{{../module}}.model.{{type}};
import com.example.modules.{{../module}}.repository.{{type}}Repository;
{{~else if (eq relationType "OneToOne")}}
import com.example.modules.{{../module}}.model.{{type}};
import com.example.modules.{{../module}}.repository.{{type}}Repository;
{{~/if}}
{{~/each}}

import org.springframework.stereotype.Service;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.List;
import java.util.ArrayList;

@Service
public class {{entityName}}Service extends BaseService<{{entityName}}> {

    protected final {{entityName}}Repository {{entityNameLowercase}}Repository;
{{~#each relationships}}
{{~#if (eq relationType "ManyToOne")}}
    private final {{type}}Repository {{name}}Repository;
{{~/if}}
{{~#if (eq relationType "ManyToMany")}}
    private final {{type}}Repository {{name}}Repository;
{{~/if}}
{{~#if (eq relationType "OneToMany")}}
    private final {{type}}Repository {{name}}Repository;
{{~/if}}
{{~#if (eq relationType "OneToOne")}}
    private final {{type}}Repository {{name}}Repository;
{{~/if}}
{{~/each}}

    public {{entityName}}Service({{entityName}}Repository repository{{~#each relationships}}{{~#if (eq relationType "ManyToOne")}},{{type}}Repository {{name}}Repository{{~/if}}{{~#if (eq relationType "OneToMany")}},{{type}}Repository {{name}}Repository{{~/if}}{{~#if (eq relationType "ManyToMany")}},{{type}}Repository {{name}}Repository{{~/if}}{{~#if (eq relationType "OneToOne")}},{{type}}Repository {{name}}Repository{{~/if}}{{~/each}})
    {
        super(repository);
        this.{{entityNameLowercase}}Repository = repository;
        {{~#each relationships}}
        {{~#if (eq relationType "ManyToOne")}}
        this.{{name}}Repository = {{name}}Repository;
        {{~/if}}
        {{~#if (eq relationType "ManyToMany")}}
        this.{{name}}Repository = {{name}}Repository;
        {{~/if}}
        {{~#if (eq relationType "OneToMany")}}
        this.{{name}}Repository = {{name}}Repository;
        {{~/if}}
        {{~#if (eq relationType "OneToOne")}}
        this.{{name}}Repository = {{name}}Repository;
        {{~/if}}
    {{~/each}}
    }

    @Override
    public {{entityName}} save({{entityName}} {{entityNameLowercase}}) {

{{#each relationships}}
    {{#if (eq relationType "OneToMany")}}
        // Cherche la relation ManyToOne correspondante dans l'entité enfant
        {{#with (lookupInverseRelationship type mappedBy)}}
            if ({{../entityNameLowercase}}.get{{capitalize ../name}}() != null) {
            List<{{../type}}> managed{{capitalize ../name}} = new ArrayList<>();
            for ({{../type}} item : {{../entityNameLowercase}}.get{{capitalize ../name}}()) {
            if (item.getId() != null) {
            {{../type}} existingItem = {{../name}}Repository.findById(item.getId())
            .orElseThrow(() -> new RuntimeException("{{../type}} not found"));
            // Utilise le nom du champ ManyToOne côté enfant pour le setter
            existingItem.set{{capitalize name}}({{../entityNameLowercase}});
            managed{{capitalize ../name}}.add(existingItem);
            } else {
            item.set{{capitalize name}}({{../entityNameLowercase}});
            managed{{capitalize ../name}}.add(item);
            }
            }
            {{../entityNameLowercase}}.set{{capitalize ../name}}(managed{{capitalize ../name}});
            }
        {{/with}}
    {{/if}}
{{/each}}

{{~#each relationships}}
    {{#if (eq relationType "ManyToOne")~}}
        if ({{../entityNameLowercase}}.get{{capitalize name}}() != null
        && {{../entityNameLowercase}}.get{{capitalize name}}().getId() != null) {
        {{type}} existing{{capitalize name}} = {{name}}Repository.findById(
        {{../entityNameLowercase}}.get{{capitalize name}}().getId()
        ).orElseThrow(() -> new RuntimeException("{{type}} not found"));
        {{../entityNameLowercase}}.set{{capitalize name}}(existing{{capitalize name}});
        }
    {{/if}}
{{~/each}}

{{~#each relationships}}
    {{~#if (eq relationType "OneToOne")}}
        if ({{../entityNameLowercase}}.get{{capitalize name}}() != null) {
        {{!-- Récupération de l'entité existante si nécessaire --}}
        {{#if }}
            // Vérifier si l'entité est déjà persistée
            {{../entityNameLowercase}}.set{{capitalize name}}(
            {{name}}Repository.findById({{../entityNameLowercase}}.get{{capitalize name}}().getId())
            .orElseThrow(() -> new RuntimeException("{{name}} not found"))
            );
        {{/if}}
        {{../entityNameLowercase}}.get{{capitalize name}}().set{{capitalize inverseField}}({{../entityNameLowercase}});
        }
{{~/if}}
{{~/each}}

        return {{entityNameLowercase}}Repository.save({{entityNameLowercase}});
    }


    public {{entityName}} update(Long id, {{entityName}} {{entityNameLowercase}}Request) {
        {{entityName}} existing = {{entityNameLowercase}}Repository.findById(id)
            .orElseThrow(() -> new RuntimeException("{{entityName}} not found"));

    // Copier les champs simples
    {{~#each fields}}
        existing.set{{capitalize name}}({{entityNameLowercase}}Request.get{{capitalize name}}());
    {{~/each}}

// Relations ManyToOne : mise à jour conditionnelle
{{~#each relationships}}
    {{~#if (eq relationType "ManyToOne")}}
        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null &&
        {{entityNameLowercase}}Request.get{{capitalize name}}().getId() != null) {

        {{type}} existing{{capitalize name}} = {{name}}Repository.findById(
        {{entityNameLowercase}}Request.get{{capitalize name}}().getId()
        ).orElseThrow(() -> new RuntimeException("{{type}} not found"));

        existing.set{{capitalize name}}(existing{{capitalize name}});
        } else {
        existing.set{{capitalize name}}(null);
        }
    {{~/if}}
{{~/each}}

// Relations ManyToMany : synchronisation sécurisée
{{~#each relationships}}

{{~#if (eq relationType "ManyToMany")}}

        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null) {
            existing.get{{capitalize name}}().clear();
            List<{{type}}> {{name}}List = {{entityNameLowercase}}Request.get{{capitalize name}}().stream()
                .map(item -> {{name}}Repository.findById(item.getId())
                    .orElseThrow(() -> new RuntimeException("{{type}} not found")))
                .collect(Collectors.toList());
        existing.get{{capitalize name}}().addAll({{name}}List);
        }
{{~/if}}
{{~/each}}

// Relations OneToMany : synchronisation sécurisée
{{~#each relationships}}
    {{~#if (eq relationType "OneToMany")}}
        existing.get{{capitalize name}}().clear();

        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null) {
        List<{{type}}> managed{{capitalize name}} = new ArrayList<>();

        for (var item : {{entityNameLowercase}}Request.get{{capitalize name}}()) {
        if (item.getId() != null) {
        {{type}} existingItem = {{name}}Repository.findById(item.getId())
        .orElseThrow(() -> new RuntimeException("{{type}} not found"));
        existingItem.set{{capitalize mappedBy}}(existing);
        managed{{capitalize name}}.add(existingItem);
        } else {
        item.set{{capitalize mappedBy}}(existing);
        managed{{capitalize name}}.add(item);
        }
        }
        existing.set{{capitalize name}}(managed{{capitalize name}});
        }
    {{~/if}}
{{~/each}}
{{#each relationships}}
    {{#if (eq relationType "OneToOne")}}

        if ({{entityNameLowercase}}Request.get{{capitalize name}}() != null
        && {{entityNameLowercase}}Request.get{{capitalize name}}().getId() != null) {

        {{type}} {{name}} = {{name}}Repository.findById(
        {{entityNameLowercase}}Request.get{{capitalize name}}().getId()
        ).orElseThrow(() -> new RuntimeException("{{type}} not found"));

        // Mise à jour de la relation côté propriétaire
        existing.set{{capitalize name}}({{name}});

        // Si la relation est bidirectionnelle et que le champ inverse existe
        {{#if mappedBy}}
            {{name}}.set{{capitalize mappedBy}}(existing);
        {{else if inverseField}}
            {{name}}.set{{capitalize inverseField}}(existing);
        {{/if}}
        }

    {{/if}}
{{/each}}

        return {{entityNameLowercase}}Repository.save(existing);
    }


}